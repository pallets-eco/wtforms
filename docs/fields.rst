Fields
======

.. module:: wtforms.fields

Fields are responsible for rendering and data conversion. They delegate to
validators for data validation.

Field definitions
-----------------

Fields are defined as members on a form in a declarative fashion::

    class MyForm(Form):
        name    = TextField(u'Full Name', [validators.required(), validators.length(max=10)])
        address = TextAreaField(u'Mailing Address', [validators.optional(), validators.length(max=200)])

When a field is defined on a form, the construction parameters are saved until
the form is instantiated. At form instantiation time, a copy of the field is 
made with all the parameters specified in the definition. Each instance of the
field keeps its own field data and errors list.

The label and validators can be passed to the constructor as sequential
arguments, while all other arguments should be passed as keyword arguments.
Some fields (such as :class:`SelectField`) can also take additional
field-specific keyword arguments. Consult the built-in fields reference for
information on those.


The Field base class
--------------------

.. autoclass:: Field
    :members: validate, process_data, process_formdata 

    **Properties**

    .. attribute:: name

        The HTML form name of this field. This is the name as defined in your 
        Form prefixed with the `prefix` passed to the Form constructor.

    .. attribute:: id

        The HTML ID of this field. By default, this is auto-generated by
        appending the field's name to :attr:`~wtforms.form.Form._idprefix`

    .. attribute:: label

        This is a :class:`Label` instance which when evaluated as a string 
        returns an HTML ``<label for="id">`` construct.

    .. attribute:: description
        
        A string containing the value of the description passed in the
        constructor to the field; this is not HTML escaped.

    .. attribute:: type

        The type of this field, as a string. This can be used in your templates
        to do logic based on the type of field:

        .. code-block:: django

            {% for field in form %}
                <tr>
                {% if field.type == "BooleanField" %}
                    <td></td>
                    <td>{{ field }} {{ field.label }}</td>
                {% else %}
                    <td>{{ field.label }}</td>
                    <td>{{ field }}</td>
                {% end %}
                </tr>
            {% endfor %}

    .. attribute:: data

        Data for this field, already coerced to the python type stored by the
        field.  Not HTML escaped.

    .. attribute:: flags
        
        An object containing boolean flags set either by the field itself, or
        by validators on the field. For example, the built-in
        :func:`~wtforms.validators.required` validator sets the `required` flag.
        An unset flag will result in :const:`False`.

        .. code-block:: django
            
            {% for field in form %}
                <tr>
                    <th>{{ field.label }} {% if field.flags.required %}*{% endif %}</th>
                    <td>{{ field }}</td>
                </tr>
            {% endfor %}

    .. attribute:: errors
        
        A list of strings with the errors for this field only.

    **Methods**

    .. automethod:: __call__
        
        If one wants to pass the "class" argument which is a reserved keyword
        in some python-based templating languages, one can do::
            
            form.field(class_="text_blob")

        This will output (for a text field):

        .. code-block:: html
            
            <input type="text" name="field_name" value="blah" class="text_blob" id="field_name" />



Built-in fields
---------------

.. class:: wtforms.fields.SelectField(default field arguments, choices=[], checker=unicode)

    Select fields keep a `choices` property which is a sequence of `(value,
    label)` pairs.  The value portion can be any type in theory, but as form
    data is sent by the browser as strings, you will need to provide a function
    which can coerce the string representation back to a comparable object.

    **Select fields with static choice values**::

        class PastebinEntry(Form):
            language = SelectField(u'Programming Language', choices=[('cpp', 'C++'), ('py', 'Python'), ('text', 'Plain Text')])

    Note that the `choices` keyword is only evaluated once, so if you want to make
    a dynamic drop-down list, you'll want to assign the choices list to the field
    after instantiation.

    **Select fields with dynamic choice values**::

        class UserDetails(Form):
            group_id = SelectField(u'Group', checker=int)

        def edit_user(request, id):
            user = User.query.get(id)
            form = UserDetails(request.POST, obj=user)
            form.group_id.choices = [(g.id, g.name) for g in Group.query.order_by('name')]

    Note we didn't pass a `choices` to the :class:`~wtforms.fields.SelectField` 
    constructor, but rather created the list in the view function. Also, the 
    `checker` keyword arg to :class:`~wtforms.fields.SelectField` says that we 
    use :func:`int()` to coerce form data.  The default checker is 
    :func:`unicode()`. 

.. autoclass:: wtforms.fields.SelectMultipleField(default field arguments, choices=[], checker=unicode)


.. autoclass:: wtforms.fields.TextField(default field arguments)

   .. code-block: jinja

        {{ form.username(size=30, maxlength=50) }}

.. autoclass:: wtforms.fields.HiddenField(default field arguments)

    HiddenField is useful for providing data from a model or the application to
    be used on the form handler side for making choices or finding records.
    Very frequently, CRUD forms will use the hidden field for an object's id.   
    
    Hidden fields are like any other field in that they can take validators and
    values and be accessed on the form object.   You should consider validating
    your hidden fields just as you'd validate an input field, to prevent from
    malicious people playing with your data.

.. autoclass:: wtforms.fields.TextAreaField(default field arguments)

    .. code-block: jinja
        
        {{ form.textarea(rows=7, cols=90) }}

.. autoclass:: wtforms.fields.PasswordField(default field arguments)

    Other than the fact that this makes a password input field, this field
    functions exactly like a text-input field.

.. autoclass:: wtforms.fields.FileField(default field arguments)

    Example usage::

        class UploadForm(Form):
            image        = FileField(u'Image File', [validators.regexp(u'^[^/\\]\.jpg$')])
            description  = TextAreaField(u'Image Description')

            def validate_image(form, field):
                if field.data:
                    field.data = re.sub(r'[^a-z0-9_.-]', '_', field.data)
        
        def upload(request):
            form = UploadForm(request.POST)
            if form.image.data:
                image_data = request.FILES[form.image.name].read()
                open(os.path.join(UPLOAD_PATH, form.image.data), 'w').write(image_data)


.. autoclass:: wtforms.fields.IntegerField(default field arguments)

.. autoclass:: wtforms.fields.BooleanField(default field arguments)

.. autoclass:: wtforms.fields.DateTimeField(default field arguments)

.. autoclass:: wtforms.fields.SubmitField(default field arguments)


Custom fields
-------------

(TODO)

